# ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性一览

## ES6

## ES7

### Array.prototype.includes()

### 幂运算符

## ES8

### async/await

### Object.values()/Object.entires()

### Object.getOwnPropertyDescriptors()

### 尾逗号

## ES9

## ES10

## ES11

### 私有变量

用来严格限制一些只用于内部使用的变量，用过在变量前面添加`#`，就可以把变量转换为它的私有变量

私有化变量的一些历史：

命名约定：

- 通过在变量前面通过添加`_`来`约定`变量或者方法是私有的
- 不能真正阻止变量被访问或者相关

```javascript
class Foo {
  constructor(name, age) {
    this._name = name
    this._age = age
  }

  get getUserInfo() {
    return `name: ${this._name}, age: ${this._age}`
  }
}
const user = new Foo('xcc', 20)
console.log(user.getUserInfo) // name: xcc, age: 20
// 访问
console.log(user._name) // xcc
// 修改
user._name = 'xcc1'
console.log(user.getUserInfo) // name: xcc1, age: 20
```

Symbol：

- 遍历阶段属性不可见
- 不能真正阻止变量被访问或者相关

```javascript
const n = Symbol('name')
const a = Symbol('age')
class Foo {
  constructor(name, age) {
    this[n] = name
    this[a] = age
  }

  get getUserInfo() {
    return `name: ${this[n]}, age: ${this[a]}`
  }
}
const user = new Foo('xcc', 20)
console.log(user.getUserInfo) // name: xcc, age: 20
// 访问
console.log(user.n) // undefined
console.log(user[n])  // xcc
// 相关
user[n] = 'xcc1'
console.log(user.getUserInfo) // name: xcc1, age: 20
```

通过`#`来定义私有变量：

- 不可访问，不可修改

```javascript
class Foo {
  #name
  #age
  constructor(name, age) {
    this.#name = name
    this.#age = age
  }

  get getUserInfo() {
    return `name: ${this.#name}, age: ${this.#age}`
  }
}
const user = new Foo('xcc', 20)
console.log(user.getUserInfo) // name: xcc, age: 20
console.log(user[#name]) // Uncaught SyntaxError: Unexpected identifier
```

### BigInt

- 在JavaScript中，所有的数字都是以双精度64位浮点格式表示的，数字范围`-(2^53 - 1)-(2^53 - 1)`，在此标准下，超出此范围的整数会丢失精度，非常大的数将自动四舍五入
- JavaScript中也提供了`Number.MAX_SAFE_INTEGER`来表示最大安全数，`Number.MIN_SAFE_INTEGER`表示最小安全数
- BigInt类型可以在标准的JavaScript中执行对大整数的运算，而不会出现精度丢失问题
- BigInt通过在整数后面添加n即可以使用，或者通过BigInt()创建实例
- BigInt类型不能和Number类型进行加法操作

```javascript
console.log(9999999999999999) // 10000000000000000
console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2)  // true
```

```javascript
typeof BigInt(1)  // bigint
const num = 999999999999999999n
const num1 = BigInt(999999999999999999)
const num2 = BigInt('999999999999999999')
console.log(num === num1) // false
console.log(num === num2) // true
console.log(BigInt(true)) // 1n
console.log(BigInt(false)) // 0n
console.log(1n == 1) // true 
console.log(1n === 1) // false
console.log(1n + 1n)  // 2n
console.log(2n - 1n)  // 1n
console.log(2n * 1n)  // 2n
console.log(2n / 1n) // 2n
console.log(1n + 1) // Cannot mix BigInt and other types, use explicit conversions
```

### 空位合并运算符(Nullish Coalescing Operator)

新增的逻辑运算符`??`，用来处理`null`和`undefined`，工作原理与运算符`||`类似，但又有所不同

很多时候我们都会写出下面的代码：

```javascript
const name = null, age = ''
// 值不存在的时候给个默认值
const userInfo = { name: name || 'xcc', age: age || 18 }
console.log(userInfo) // { name: 'xcc', 18 }
// || 运算符是第一个值为真就返回第一个，不然返回第二个值
console.log('' || 1)  // 1
console.log(null || 1)  // 1
console.log(undefined || 1) // 1
console.log(false || 1)  // 1
console.log(1 || 'xcc') // 1
```

当使用`??`运算符时：

```javascript
const name = null, age = ''
const userInfo = { name: name ?? 'xcc', age: age ?? 18 }
console.log(userInfo) // {name: 'null', age: ''}

console.log('' ?? 1)  // ''
console.log(null ?? 1)  // 1
console.log(undefined ?? 1) // 1
console.log(false ?? 1)  // false
console.log(1 ?? 'xcc') // 1
```

注意事项：

- 不可以直接与其它运算符组合使用，例如&&、||

```javascript
false || undefined ?? 'xcc'  // Uncaught SyntaxError: Unexpected token '??'
(false || undefined) ?? 'xcc'  // xcc
```

### 可选链运算符(Optional Chaining Operator)

`可选链运算符(Optional Chaining Operator)`处于ES2020提案的第4阶段。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性，简化了深层取值的边界判断问题

很多时候我们在对深层嵌套字段取值时，经常会写出下面的代码：

```javascript
(data && data.children).map(item => {})
```

上面的代码，会检查data中children是否存在，再进行遍历操作，如果有其他的更深层次的取值操作，可能需要考虑的边界条件就更多了。

`可选链运算符可以为我们检查嵌套属性，而不必显示的判断值是否存在。`用?就可以检查空值之后的运算符

静态属性使用：

```javascript
object?.children
```

动态属性使用：

```javascript
object?.[expression]
```

示例：

```javascript
const userInfo = { children: [{ name: 'xcc', age: 20 }, { name: 'xcc1', age: 25 }], info: { address: 'wuhan' }, obj: null }

// 变量children
userInfo?.children.map(item => {})
console.log(userInfo.obj.name)  // TypeError: Cannot read property 'name' of undefined
// 取值不到时会提前返回
console.log(userInfo?.obj?.name)  // undefined
```

### Promise.allSettled

### 动态导入(Dynamic Import)

### 导入特定命名空间(Module Namespace Exports)

### 新增全局对象(globalThis)

`globalThis`是新增的一种访问全局对象的标准方法

以前：

- 浏览器：通过window/self来访问全局对象
- Node：通过global来访问全局对象
- Web Worker：通过self来访问

在很多需要兼容以上情景的js文件中，会看到下面方法：

```javascript
const getGlobal = () => {
  if (self) return self
  if (window) return window
  if (global) return global
  throw new Error('error')
}
```

而现在：

```javascript
const getGlobal = () => {
  if (globalThis) return globalThis
  throw new Error('error')
}
```

```javascript
// 浏览器
console.log(globalThis === window)  // true
// web worker
console.log(globalThis === self)  // true
// node
console.log(globalThis === global)  // true
```

### String.prototype.matchAll

matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器

## ES12

### replaceAll

- replace这个大家应该都用过，就是对匹配到的第一个字符进行替换，而`replaceAll`，嗯，看到字面意思，你没有想错，就是替换所有匹配到的字符

```javascript
const str = '12121212'
// 匹配第一个
console.log(str.replace('1', '我')) // "我2121212"
// 正则匹配所有
console.log(str.replace(/1/g, '我'))  // 我2我2我2我2
// replaceAll
console.log(str.replaceAll('1', '我')) // 我2我2我2我2
// replaceAll中正则
console.log(str.replaceAll(/1/g, '我')) // 我2我2我2我2
console.log(str.replaceAll(/1/, '我')) // TypeError: String.prototype.replaceAll called with a non-global RegExp argument
```

### Promise.any

- Promise.any列表中的任意一个promise成功，就返回第一个成功的结果状态，如果全部失败，就返回所有请求失败

```javascript
// 输出第一个正常返回的
Promise.any([
  new Promise((resolve, reject) => setTimeout(reject, 1000, 'reject')),
  new Promise((resolve, reject) => setTimeout(resolve, 1500, 'resolve1')),
  new Promise((resolve, reject) => setTimeout(resolve, 1000, 'resolve1'))
])
.then(res => {
  console.log(`结果输出：${res}`) // 结果输出：resolve1
})
.catch(error => console.log(error))

// 假如全部错误
Promise.any([
  new Promise((resolve, reject) => setTimeout(reject, 1000, 'reject')),
  new Promise((resolve, reject) => setTimeout(reject, 1500, 'reject')),
  new Promise((resolve, reject) => setTimeout(reject, 2000, 'reject'))
])
.then(res => {
  console.log(`结果输出：${res}`)
})
.catch(error => console.log(error)) // AggregateError: All promises were rejected
```

### WeakRefs

### 逻辑运算符和赋值表达式

### 数字分隔符号

## 参考资料

- [JavaScript中的私有变量](https://zhuanlan.zhihu.com/p/33929414)
